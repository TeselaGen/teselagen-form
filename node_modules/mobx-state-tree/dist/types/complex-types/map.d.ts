import { ObservableMap, IMapWillChange, IMapDidChange } from "mobx";
import { IJsonPatch, INode, IType, IComplexType, ComplexType, TypeFlags, IContext, IValidationResult, ObjectNode } from "../../internal";
export interface IExtendedObservableMap<T> extends ObservableMap<string, T> {
    put(value: T | any): this;
}
export declare enum MapIdentifierMode {
    UNKNOWN = 0,
    YES = 1,
    NO = 2,
}
export declare class MapType<S, T> extends ComplexType<{
    [key: string]: S;
}, IExtendedObservableMap<T>> {
    shouldAttachNode: boolean;
    subType: IType<any, any>;
    identifierMode: MapIdentifierMode;
    identifierAttribute: string | undefined;
    readonly flags: TypeFlags;
    constructor(name: string, subType: IType<any, any>);
    instantiate(parent: ObjectNode | null, subpath: string, environment: any, snapshot: S): INode;
    describe(): string;
    createNewInstance: () => ObservableMap<any, any>;
    finalizeNewInstance: (node: INode, snapshot: any) => void;
    getChildren(node: ObjectNode): ReadonlyArray<INode>;
    getChildNode(node: ObjectNode, key: string): INode;
    willChange(change: IMapWillChange<any, any>): IMapWillChange<any, any> | null;
    private processIdentifier(expected, node);
    getValue(node: ObjectNode): any;
    getSnapshot(node: ObjectNode): {
        [key: string]: any;
    };
    didChange(change: IMapDidChange<any, any>): void;
    applyPatchLocally(node: ObjectNode, subpath: string, patch: IJsonPatch): void;
    applySnapshot(node: ObjectNode, snapshot: any): void;
    getChildType(key: string): IType<any, any>;
    isValidSnapshot(value: any, context: IContext): IValidationResult;
    getDefaultSnapshot(): {};
    removeChild(node: ObjectNode, subpath: string): void;
}
export declare function map<S, T>(subtype: IComplexType<S, T>): IComplexType<{
    [key: string]: S;
}, IExtendedObservableMap<T>>;
export declare function isMapType<S, T>(type: any): type is IComplexType<{
    [key: string]: S;
}, IExtendedObservableMap<T>>;
